import{dX as v,eC as N,f$ as C,g0 as q,g1 as B,g2 as D,g3 as I,l as k,bD as z,g4 as F,bC as G,dW as l,g5 as H,ea as P,g6 as T,r as e,t as a,x as U}from"./index-CorgkmYx.js";import{e as m}from"./mat4f64-CSKppSlJ.js";import{b as p,x as W,v as M}from"./quat-DBd2Nb1m.js";import{e as g}from"./quatf64-aQ5IuZRd.js";function s(t=w){return[t[0],t[1],t[2],t[3]]}function c(t,n,r=s()){return v(r,t),r[3]=n,r}function O(t,n=s()){const r=q(i,t);return j(n,N(M(n,r))),n}function y(t,n,r=s()){return p(i,t,h(t)),p(d,n,h(n)),W(i,d,i),j(r,N(M(r,i)))}function Q(t,n,r,x=s()){return c(B,t,u),c(D,n,A),c(I,r,$),y(u,A,u),y(u,$,x),x}function R(t){return t}function X(t){return t[3]}function h(t){return C(t[3])}function j(t,n){return t[3]=n,t}const w=[0,0,1,0],i=g(),d=g();s();const u=s(),A=s(),$=s();var f;let o=f=class extends k{constructor(t){super(t),this.translation=z(),this.rotationAxis=F(w),this.rotationAngle=0,this.scale=G(1,1,1)}get rotation(){return c(this.rotationAxis,this.rotationAngle)}set rotation(t){this.rotationAxis=l(t),this.rotationAngle=X(t)}get localMatrix(){const t=m();return p(b,this.rotation,h(this.rotation)),H(t,b,this.translation,this.scale),t}get localMatrixInverse(){return P(m(),this.localMatrix)}equals(t){return this===t||t!=null&&T(this.localMatrix,t.localMatrix)}clone(){const t={translation:l(this.translation),rotationAxis:l(this.rotationAxis),rotationAngle:this.rotationAngle,scale:l(this.scale)};return new f(t)}};e([a({type:[Number],nonNullable:!0,json:{write:!0}})],o.prototype,"translation",void 0),e([a({type:[Number],nonNullable:!0,json:{write:!0}})],o.prototype,"rotationAxis",void 0),e([a({type:Number,nonNullable:!0,json:{write:!0}})],o.prototype,"rotationAngle",void 0),e([a({type:[Number],nonNullable:!0,json:{write:!0}})],o.prototype,"scale",void 0),e([a()],o.prototype,"rotation",null),e([a()],o.prototype,"localMatrix",null),e([a()],o.prototype,"localMatrixInverse",null),o=f=e([U("esri.geometry.support.MeshTransform")],o);const b=g(),S=o;export{S as N,Q as d,s as j,O as k,R as w,h as z};
