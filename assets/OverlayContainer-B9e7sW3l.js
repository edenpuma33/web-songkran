import{r as n,hX as D,hY as E,hZ as k,ab as J,hH as Q,an as G,gl as X,av as Y,hI as V,ge as ee,gj as te,gf as se,gg as ie,hJ as oe,gh as ne,aZ as re,h_ as ae,h$ as L}from"./index-CorgkmYx.js";import{r as de}from"./vec3f32-nZdmKIgz.js";import{n as he}from"./WGLContainer-bPMGktCv.js";import{t as pe,a as q,i as ue}from"./FeatureCommandQueue-BHjvkz0y.js";import{j as le,a as P,h as ce,G as fe,C as y,H as me,l as ge,w as ve,b as B,g as a,m as H,I as xe,P as U,v as ye,c as we,S as _e,e as Me}from"./UpdateTracking2D-CdU6XMPT.js";class I extends xe{}n([B(0,y)],I.prototype,"pos",void 0),n([B(1,y)],I.prototype,"uv",void 0);class $e extends ye{}class W extends U{}n([a(we)],W.prototype,"dvs",void 0);class g extends U{}n([a(y)],g.prototype,"perspective",void 0),n([a(y)],g.prototype,"texSize",void 0),n([a(P)],g.prototype,"wrapAroundShift",void 0),n([a(P)],g.prototype,"opacity",void 0),n([a(_e)],g.prototype,"texture",void 0);class x extends le{vertex(t){const e=t.uv.divide(this.config.texSize),s=new P(1).add(ce(e,this.config.perspective)),i=new fe(t.pos.add(new y(this.config.wrapAroundShift,0)),1),o=this.transform.dvs.multiply(i);return{uv:e,glPosition:new me(o.xy.multiply(s),0,s)}}fragment(t){const e=ge(this.config.texture,t.uv).multiply(this.config.opacity),s=new ve;return s.glFragColor=e,s}}n([a(W)],x.prototype,"transform",void 0),n([a(g)],x.prototype,"config",void 0),n([D(0,H(I))],x.prototype,"vertex",null),n([D(0,H($e))],x.prototype,"fragment",null);let Se=class extends pe{constructor(){super(...arguments),this.type=Me.Overlay,this._mesh=null,this.shaders={overlay:new x}}render(t,e){const{context:s,painter:i}=t,o=this._getMesh(t,e);i.setPipelineState(q);const{isWrapAround:d,wrapAroundShift:l}=e.config,c={...e.config,wrapAroundShift:0},f={shader:this.shaders.overlay,uniforms:{transform:e.transform,config:c},defines:null,optionalAttributes:null,useComputeBuffer:!1};i.setPipelineState({...q,stencil:{write:!1,test:{compare:k.EQUAL,op:{fail:E.KEEP,zFail:E.KEEP,zPass:E.REPLACE},ref:0,mask:255}}}),i.submitDrawMeshUntyped(s,f,o),d&&(c.wrapAroundShift=l,i.submitDrawMeshUntyped(s,f,o))}shutdown(){J(this._mesh)}_getMesh(t,e){const{context:s}=t;if(this._mesh){const i=this._mesh.vertexBuffers.get("positions");if(!i)throw new Error("Buffer not found");i.setData(e.position)}else{const i=e.index!=null?e.index.length:e.position.length/2;this._mesh=new ue(s,{vertex:{positions:e.position,uvs:e.tex},index:e.index!=null?{index:e.index}:void 0,groups:[{attributes:[{name:"pos",count:2,type:G.FLOAT,location:0,vertex:"positions",stride:8,offset:0},{name:"tex",count:2,type:G.UNSIGNED_SHORT,location:1,vertex:"uvs",stride:4,offset:0}],index:e.index!=null?"index":void 0,primitive:Q.TRIANGLE_STRIP}],parts:[{group:0,start:0,count:i}]})}return this._mesh}};class Ie extends he{constructor(){super(...arguments),this._viewStateId=-1,this._dvsMat3=X(),this._overlayTechnique=new Se}get dvsMat3(){return this._dvsMat3}beforeRender(t){this._updateMatrices(t),this._updateOverlays(t,this.children);for(const e of this.children)e.beforeRender(t)}doRender(t){if(t.drawPhase!==Y.MAP||!this.visible)return;super.doRender(t);const e=this._overlayTechnique;for(const s of this.children)s.draw(t,e)}onDetach(){this._overlayTechnique.shutdown()}_updateMatrices(t){const{state:e}=t,{id:s,size:i,pixelRatio:o,resolution:d,rotation:l,viewpoint:c,displayMat3:f}=e;if(this._viewStateId===s)return;const w=L(l),h=o*i[0],m=o*i[1];this._localOrigin=c.targetGeometry.clone();const{x:v,y:$}=this._localOrigin,_=V(v,e.spatialReference);this._localOrigin.x=_,this._localOrigin.y=$;const S=d*h,b=d*m,r=ee(this._dvsMat3);te(r,r,f),se(r,r,ie(h/2,m/2)),oe(r,r,de(h/S,-m/b,1)),ne(r,r,-w),this._viewStateId=s}_updateOverlays(t,e){const{state:s}=t,{rotation:i,spatialReference:o,worldScreenWidth:d,size:l,viewpoint:c}=s,f=this._localOrigin;let w,h=0;const m=re(o);if(m&&o.isWrappable){const v=l[0],$=l[1],_=L(i),S=Math.abs(Math.cos(_)),b=Math.abs(Math.sin(_)),r=Math.round(v*S+$*b),[j,T]=m.valid,p=ae(o),{x:z,y:F}=c.targetGeometry,N=[z,F],O=[0,0];s.toScreen(O,N);const M=[0,0];let R;R=r>d?.5*d:.5*r;const C=Math.floor((z+.5*p)/p),K=j+C*p,Z=T+C*p,A=[O[0]+R,0];s.toMap(M,A),M[0]>Z&&(h=p),A[0]=O[0]-R,s.toMap(M,A),M[0]<K&&(h=-p),w={worldWidth:p,xBounds:[j,T]}}for(const v of e)v.updateDrawCoords(f,h,o,w)}}export{Ie as u};
