const Z={convertToGEGeometry:o,exportPoint:c,exportPolygon:x,exportPolyline:m,exportMultipoint:l,exportExtent:p};function o(t,n){return n==null?null:t.convertJSONToGeometry(n)}class r{constructor(n,e,i){this.x=n,this.y=e,this.spatialReference=i,this.z=void 0,this.m=void 0}}function c(t,n,e){const i=new r(t.getPointX(n),t.getPointY(n),e),s=t.hasZ(n),h=t.hasM(n);return s&&(i.z=t.getPointZ(n)),h&&(i.m=t.getPointM(n)),i}class u{constructor(n,e,i,s){this.rings=n,this.spatialReference=e,this.hasZ=void 0,this.hasM=void 0,i&&(this.hasZ=i),s&&(this.hasM=s)}}function x(t,n,e){return new u(t.exportPaths(n),e,t.hasZ(n),t.hasM(n))}class f{constructor(n,e,i,s){this.paths=n,this.spatialReference=e,this.hasZ=void 0,this.hasM=void 0,i&&(this.hasZ=i),s&&(this.hasM=s)}}function m(t,n,e){return new f(t.exportPaths(n),e,t.hasZ(n),t.hasM(n))}class d{constructor(n,e,i,s){this.points=n,this.spatialReference=e,this.hasZ=void 0,this.hasM=void 0,i&&(this.hasZ=i),s&&(this.hasM=s)}}function l(t,n,e){return new d(t.exportPoints(n),e,t.hasZ(n),t.hasM(n))}class M{constructor(n,e,i,s,h){this.xmin=n,this.ymin=e,this.xmax=i,this.ymax=s,this.spatialReference=h,this.zmin=void 0,this.zmax=void 0,this.mmin=void 0,this.mmax=void 0}}function p(t,n,e){const i=t.hasZ(n),s=t.hasM(n),h=new M(t.getXMin(n),t.getYMin(n),t.getXMax(n),t.getYMax(n),e);if(i){const a=t.getZExtent(n);h.zmin=a.vmin,h.zmax=a.vmax}if(s){const a=t.getMExtent(n);h.mmin=a.vmin,h.mmax=a.vmax}return h}export{Z as t};
